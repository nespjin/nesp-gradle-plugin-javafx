/*
 * Copyright (C) 2021 The NESP Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.nesp.gradle.plugin.javafx.fxml;

import com.nesp.gradle.plugin.javafx.BaseTask;
import com.nesp.gradle.plugin.javafx.JavaFxPlugin;
import com.nesp.gradle.plugin.javafx.reflect.MethodExecutableElement;
import com.squareup.javapoet.*;
import groovyjarjarantlr4.v4.codegen.model.decl.CodeBlock;
import javafx.fxml.FXML;
import org.gradle.api.Project;
import org.gradle.api.tasks.TaskAction;
import org.gradle.internal.impldep.org.apache.http.util.TextUtils;

import javax.inject.Inject;
import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;


public abstract class GenerateBaseControllerClassFileTask extends BaseTask {
    private static final String TAG = "GenerateBaseControllerClassFileTask";

    private static final String[] SUPPORT_FILE_TYPES = new String[]{
            ".fxml"
    };

    private final String baseControllerSuperClassName;
    private final List<String> baseControllerSuperInterfaces;

    @Inject
    public GenerateBaseControllerClassFileTask(String superClass, List<String> superInterfaces) {
        this.baseControllerSuperClassName = superClass;
        this.baseControllerSuperInterfaces = superInterfaces;
    }

    @TaskAction
    public void run() {
        final Project project = getProject();
        final File desFile = getSourcePathGenerate();
        final String packageName = getPackageName();
        final ClassLoader classLoader = getClassLoader();

        final List<File> fxmlFiles = scanProjectFxmlFiles(project);
        Type baseControllerSuperClass = null;

        if (!baseControllerSuperClassName.isEmpty()) {
            try {
                baseControllerSuperClass = classLoader.loadClass(baseControllerSuperClassName);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }

        final List<Type> superInterfaces = new ArrayList<>();

        if (!baseControllerSuperInterfaces.isEmpty()) {
            for (String baseControllerSuperInterfaceName : baseControllerSuperInterfaces) {
                try {
                    superInterfaces.add(classLoader.loadClass(baseControllerSuperInterfaceName));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        final List<BaseControllerClass> baseControllerClasses = new ArrayList<>();
        for (final File fxmlFile : fxmlFiles) {
            final BaseControllerFXMLParser baseControllerFXMLParser = new BaseControllerFXMLParser();
            baseControllerFXMLParser.setClassLoader(classLoader);
            try {
                baseControllerFXMLParser.parse(fxmlFile);
                baseControllerClasses.add(baseControllerFXMLParser.getBaseControllerClass());
            } catch (FXMLParseException e) {
                e.printStackTrace();
            }
        }

        for (final BaseControllerClass baseControllerClass : baseControllerClasses) {

            TypeSpec.Builder classBuilder = TypeSpec
                    .classBuilder(baseControllerClass.getClassName())
                    .addJavadoc("Generated by NespJavaFxPlugin, do not edit!!!")
                    .addModifiers(Modifier.ABSTRACT)
                    .addModifiers(Modifier.PUBLIC);

            if (baseControllerSuperClass != null) {
                classBuilder.superclass(baseControllerSuperClass);
            }

            if (!superInterfaces.isEmpty()) {
                for (Type superInterface : superInterfaces) {
                    classBuilder.addSuperinterface(superInterface);
                }
            }

            List<ClassField> fields = baseControllerClass.getFields();
            for (ClassField field : fields) {
                FieldSpec.Builder filedBuilder = FieldSpec.builder(field.getType(), field.getName(), Modifier.PUBLIC);
                filedBuilder.annotations.add(AnnotationSpec.builder(FXML.class).build());
                classBuilder.addField(filedBuilder.build());
            }

            List<ClassMethod> classMethods = baseControllerClass.getClassMethods();
            for (ClassMethod classMethod : classMethods) {
                MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(classMethod.getName());
                if (classMethod.getModifier() == com.nesp.gradle.plugin.javafx.fxml.Modifier.ABSTRACT) {
                    methodBuilder.addModifiers(Modifier.ABSTRACT);
                } else if (classMethod.getModifier() == com.nesp.gradle.plugin.javafx.fxml.Modifier.PUBLIC) {
                    methodBuilder.addModifiers(Modifier.PUBLIC);
                } else if (classMethod.getModifier() == com.nesp.gradle.plugin.javafx.fxml.Modifier.PROTECTED) {
                    methodBuilder.addModifiers(Modifier.PROTECTED);
                } else if (classMethod.getModifier() == com.nesp.gradle.plugin.javafx.fxml.Modifier.PRIVATE) {
                    methodBuilder.addModifiers(Modifier.PRIVATE);
                } else if (classMethod.getModifier() == com.nesp.gradle.plugin.javafx.fxml.Modifier.FINAL) {
                    methodBuilder.addModifiers(Modifier.FINAL);
                }

                List<ClassMethod.Param> params = classMethod.getParams();
                Class<?>[] paramClasses = null;
                if (params != null) {
                    paramClasses = new Class[params.size()];
                    for (int i = 0, paramsSize = params.size(); i < paramsSize; i++) {
                        final ClassMethod.Param param = params.get(i);
                        try {
                            final String className = param.getType().getTypeName();
                            if (className != null && !className.isEmpty()) {
                                paramClasses[i] = Class.forName(className);
                            }
                        } catch (ClassNotFoundException e) {
                            e.printStackTrace();
                        }
                        ParameterSpec parameterSpec =
                                ParameterSpec.builder(param.getType(), param.getName(), Modifier.FINAL).build();
                        methodBuilder.addParameter(parameterSpec);
                    }
                }

                final StringBuilder methodString = new StringBuilder(classMethod.getName() + "(");
                if (params != null && !params.isEmpty()) {
                    for (int i = 0, paramsSize = params.size(); i < paramsSize; i++) {
                        final ClassMethod.Param param = params.get(i);
                        if (i != 0) {
                            methodString.append(",");
                        }
                        methodString.append(param.getName());
                    }
                }
                methodString.append(")");

                if (baseControllerSuperClass != null) {
                    final Class<?> baseControllerSuperClass1 = (Class<?>) baseControllerSuperClass;
                    Method method = null;
                    try {
                        method = baseControllerSuperClass1
                                .getDeclaredMethod(classMethod.getName(), paramClasses);
                    } catch (NoSuchMethodException | SecurityException e) {
                        JavaFxPlugin.printLog(TAG, "method " + methodString
                                + " not found in " + baseControllerSuperClass);
                    }

                    if (method != null) {
                        // Found super method, add override code
                        // TODO: Replace with MethodSpec.override(method)
                        methodBuilder.addAnnotation(Override.class);
                        methodBuilder.addCode("super." + methodString + ";");
                    }

                }

                methodBuilder.returns(classMethod.getReturnType());
                classBuilder.addMethod(methodBuilder.build());
            }

            JavaFile.Builder javaFileBuilder = JavaFile.builder(packageName, classBuilder.build());
            File file = new File(desFile.getAbsolutePath());
            if (!file.getParentFile().exists()) {
                if (!file.getParentFile().mkdirs()) {
                    JavaFxPlugin.printLog(TAG, "file's parent create failed");
                }
            }
            try {
                javaFileBuilder.build().writeTo(file);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }

    /**
     * Scan all fxml files under project.
     *
     * @param project project.
     * @return Fxml files scanned.
     */
    private List<File> scanProjectFxmlFiles(Project project) {
        File fxmlFilesRootDir = new File(project.getProjectDir() + "/src/main/resources");
        return scanDirFxmlFiles(fxmlFilesRootDir);
    }

    /**
     * Scan all fxml files recursive under dir.
     *
     * @param dir Root directory.
     * @return Fxml files scanned.
     */
    private List<File> scanDirFxmlFiles(File dir) {
        List<File> result = new LinkedList<>();
        if (dir.isFile()) return result;
        final File[] files = dir.listFiles();
        if (files == null) return result;
        for (File file : files) {
            if (file.isFile()) {
                if (isSupportFile(file.getName())) {
                    result.add(file);
                }
            } else if (file.isDirectory()) {
                result.addAll(scanDirFxmlFiles(file));
            }
        }
        return result;
    }

    /**
     * Check the file is supported.
     *
     * @param fileName file name for checking.
     * @return true if supported, otherwise false.
     */
    private boolean isSupportFile(String fileName) {
        for (String supportFileType : SUPPORT_FILE_TYPES) {
            if (fileName.endsWith(supportFileType)) {
                return true;
            }
        }
        return false;
    }

}
